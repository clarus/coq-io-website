<%= header(:getting_started) %>
      <div class="row">
        <div class="col-md-12">
          <h1>Getting started</h1>
          <p>To install the Coq.io library, enable the <a href="https://github.com/coq/repo-stable">repo-stable</a> OPAM repository and run:</p>
          <pre>opam install -j4 -v coq:io:system</pre>
          This will install the main library <code>coq:io</code> and some basic effects <code>coq:io:system</code> to interact with your operating system.

          <h2>Write a Hello World</h2>
          Open your favorite <a href="https://coq.inria.fr/">Coq</a> editor and type:
          <pre>Require Import Coq.Lists.List.
Require Import Io.All.
Require Import Io.System.All.
Require Import ListString.All.

Import ListNotations.
Import C.Notations.

(** The classic Hello World program. *)
Definition hello_world (argv : list LString.t) : C.t System.effect unit :=
  System.log (LString.s "Hello world!").</pre>
          <p>We load some libraries and write the <code>hello_world</code> program by calling the <code>System.log</code> function to print a message on the terminal. The return type of the program is <code>C.t System.effects unit</code>, which means this is an <em>impure</em> computation with <em>system</em> effects and returning a value of type <code>unit</code>. The impure computations are the computations which are not purely functional, in the sense they do some IO or modify a state variable for example. The command line arguments are given by the list of strings <code>argv</code>, but not used here.</p>

          <p>To compile the <code>hello_world</code> program, add the lines:</p>
          <pre>Definition main := Extraction.launch hello_world.
Extraction "extraction/main" main.</pre>
          <p>to generate an <a href="https://ocaml.org/">OCaml</a> file <code>main.ml</code>. We compile and run this file with:</p>
          <pre>ocamlbuild main.native -use-ocamlfind -package io-system
./main.native</pre>
          <p>This should display <code>Hello world!</code> on the terminal.</p>

          <h2>More examples</h2>
          <p>The full documentation of the <code>coq:io:system</code> library is available on <em>TODO</em>.</p>

          <h3>Your name</h3>
          <p>The following program reads a name on the command line and answers hello to this name:</p>
          <pre>(** Ask for the user name and answer hello. *)
Definition your_name (argv : list LString.t) : C.t System.effect unit :=
  do! System.log (LString.s "What is your name?") in
  let! name := System.read_line in
  match name with
  | None => ret tt
  | Some name => System.log (LString.s "Hello " ++ name ++ LString.s "!")
  end.</pre>
          <p>We see here how to compose impure computations in sequence with the <code>do!</code> and <code>let!</code> keywords. The construct:</p>
          <pre>let! x := e1 in e2</pre>
          <p>executes <code>e1</code>, assigns the result to <code>x</code> and then executes <code>e2</code>. The <code>do!</code> is a syntactic sugar for a <code>let!</code> with an empty variable name. We use the <code>System.read_line</code> function which gets a new line on the standard input. If the <code>read_line</code> operation fails we returns the pure value <code>tt</code> of type <code>unit</code> using the <code>ret</code> operator, else we print the user name on the terminal. We run this program as before by compilation to OCaml.</p>

          <h3>Cat</h3>
          <p>This program opens a file and write its content:</p>
          <pre>(** Display the content of a file. *)
Definition cat (argv : list LString.t) : C.t System.effect unit :=
  match argv with
  | [_; file_name] =>
    let! content := System.read_file file_name in
    match content with
    | None => System.log (LString.s "Cannot read the file.")
    | Some content => System.log content
    end
  | _ => System.log (LString.s "Expected one parameter.")
  end.</pre>
        <p>It is analogous to the <code>cat</code> Unix command. It uses the command line argument to get the file name to display, and then read the file with <code>System.read_file</code>.</p>

          <h3>Uname</h3>
          <p>This program wrap the <code>uname</code> command to display the operating system kind and the type of machine:</p>
          <pre>Require Import Coq.ZArith.ZArith.

(** A wrapper for the `uname` command. *)
Definition uname (argv : list LString.t) : C.t System.effect unit :=
  let! os := System.eval [LString.s "uname"; LString.s "-o"] in
  let! machine := System.eval [LString.s "uname"; LString.s "-m"] in
  match (os , machine) with
  | (Some (0%Z, os, _), Some (0%Z, machine, _)) =>
    do! System.log (LString.s "OS: " ++ LString.trim os) in
    System.log (LString.s "Machine: " ++ LString.trim machine)
  | _ => ret tt
  end.</pre>
        <p>We use the command <code>System.eval</code> to evaluate a command and get its status code and output. If the two <code>uname</code> calls are successful, we retrieve the OS and machine names and display them. The <code>0%Z</code> stands for the zero in the type <code>Z</code> of the relative integers. A null value means by convention that the commands were successful.</p>

          <h2>The effects system</h2>

          <h2>Use concurrency</h2>

          <h2>Verification by use cases</h2>
        </div>
      </div>
<%= footer %>
