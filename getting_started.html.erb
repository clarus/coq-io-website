<%= header(:getting_started) %>
      <div class="row">
        <div class="col-md-12">
          <h1>Getting started</h1>
          <p>To install the Coq.io library, enable the <a href="https://github.com/coq/repo-stable">repo-stable</a> OPAM repository and run:</p>
          <pre>opam install -j4 -v coq:io:system</pre>
          This will install the main library <code>coq:io</code> and some basic effects <code>coq:io:system</code> to interact with your operating system.

          <h2>Write a Hello World</h2>
          Open your favorite <a href="https://coq.inria.fr/">Coq</a> editor and type:
          <pre>Require Import Coq.Lists.List.
Require Import Io.All.
Require Import Io.System.All.
Require Import ListString.All.

Import ListNotations.
Import C.Notations.

(** The classic Hello World program. *)
Definition hello_world (argv : list LString.t) : C.t System.effect unit :=
  System.log (LString.s "Hello world!").</pre>
          <p>We load some libraries and write the <code>hello_world</code> program by calling the <code>System.log</code> function to print a message on the terminal. The return type of the program is <code>C.t System.effects unit</code>, which means this is an <em>impure</em> computation with the <em>system</em> effect and returning a value of type <code>unit</code>. The impure computations are the computations which are not purely functional, in the sense they do some effects, like IO or modifying a state variable. The system effect is an effect we use to do IO with the system. The command-line arguments are given by the list of strings <code>argv</code>, but are not used here.</p>

          <p>To compile the <code>hello_world</code> program to generate an <a href="https://ocaml.org/">OCaml</a> file <code>main.ml</code>, add the lines:</p>
          <pre>Definition main := Extraction.launch hello_world.
Extraction "extraction/main" main.</pre>
          <p>We compile and run <code>main.ml</code> with:</p>
          <pre>ocamlbuild main.native -use-ocamlfind -package io-system
./main.native</pre>
          <p>This should display <code>Hello world!</code> on the terminal.</p>

          <h2>More examples</h2>
          <p>The full documentation of the <code>coq:io:system</code> library is available on <em>TODO</em>.</p>

          <h3>Your name</h3>
          <p>The following program reads a name on the command-line and answers "hello" to this name:</p>
          <pre>(** Ask for the user name and answer hello. *)
Definition your_name (argv : list LString.t) : C.t System.effect unit :=
  do! System.log (LString.s "What is your name?") in
  let! name := System.read_line in
  match name with
  | None => ret tt
  | Some name => System.log (LString.s "Hello " ++ name ++ LString.s "!")
  end.</pre>
          <p>We see here how to compose impure computations in sequence with the <code>do!</code> and <code>let!</code> keywords. The construct:</p>
          <pre>let! x := e1 in e2</pre>
          <p>executes <code>e1</code>, assigns the result to <code>x</code> and then executes <code>e2</code>. The <code>do!</code> is a syntactic sugar for a <code>let!</code> without a variable <code>x</code>, so for the case of <code>e1</code> returning the <code>unit</code> value. We use the <code>System.read_line</code> function which reads a new line on the standard input. If the <code>read_line</code> operation fails, we returns the pure value <code>tt</code> of type <code>unit</code> using the <code>ret</code> operator, else we print the user name on the terminal. We run this program as before by compilation to OCaml.</p>

          <h3>Cat</h3>
          <p>This program opens a file and displays its content:</p>
          <pre>(** Display the content of a file. *)
Definition cat (argv : list LString.t) : C.t System.effect unit :=
  match argv with
  | [_; file_name] =>
    let! content := System.read_file file_name in
    match content with
    | None => System.log (LString.s "Cannot read the file.")
    | Some content => System.log content
    end
  | _ => System.log (LString.s "Expected one parameter.")
  end.</pre>
        <p>It is analogous to the <code>cat</code> Unix command. It uses the command-line argument to get the file name to display, and then read the file with <code>System.read_file</code>.</p>

          <h3>Uname</h3>
          <p>This program wrap the <code>uname</code> command to display the operating system kind and the type of machine:</p>
          <pre>Require Import Coq.ZArith.ZArith.

(** A wrapper for the `uname` command. *)
Definition uname (argv : list LString.t) : C.t System.effect unit :=
  let! os := System.eval [LString.s "uname"; LString.s "-o"] in
  let! machine := System.eval [LString.s "uname"; LString.s "-m"] in
  match (os , machine) with
  | (Some (0%Z, os, _), Some (0%Z, machine, _)) =>
    do! System.log (LString.s "OS: " ++ LString.trim os) in
    System.log (LString.s "Machine: " ++ LString.trim machine)
  | _ => ret tt
  end.</pre>
          <p>We use the function <code>System.eval</code> to evaluate a command and get its status code and output. If the two <code>uname</code> calls are successful, we retrieve the OS and machine names and display them. The <code>0%Z</code> stands for the zero in the type <code>Z</code> of the relative integers. A null value means by convention that the commands were successful.</p>

          <h2>Use concurrency</h2>
          <p>In order not to freeze, interactive programs usually need to run many IO operations in parallel. Consider for example an application which must keep a reactive user interface while doing slow network operations.</p>
          <p>To run two operations in parallel, we use the <code>join</code> operator:</p>
          <pre>join : C.t E A -> C.t E B -> C.t E (A * B)</pre>
          <p>with <code>join x y</code> concurrently computing the couple of results for the computations <code>x</code> and <code>y</code>.</p>
          <p>In the following program we concurrently run two sleep operations of 4 and 2 seconds:</p>
          <pre>(** Do two sleep operations. *)
Definition double_sleep (argv : list LString.t) : C.t System.effect unit :=
  let! _ : unit * unit :=
    join
      (let! _ := System.eval [LString.s "sleep"; LString.s "4"] in
      System.log (LString.s "Task of 4 seconds ended."))
      (let! _ := System.eval [LString.s "sleep"; LString.s "2"] in
      System.log (LString.s "Task of 2 seconds ended.")) in
  ret tt.</pre>
          <p>The output is:</p>
          <pre>Task of 2 seconds ended.
Task of 4 seconds ended.</pre>
          <p>and the total execution time is 4 seconds. If the sleeps were done sequentially:</p>
          <pre>(** Do two sleep operations (sequential). *)
Definition double_sleep_seq (argv : list LString.t) : C.t System.effect unit :=
  let! _ := System.eval [LString.s "sleep"; LString.s "4"] in
  do! System.log (LString.s "Task of 4 seconds ended.") in
  let! _ := System.eval [LString.s "sleep"; LString.s "2"] in
  System.log (LString.s "Task of 2 seconds ended.").</pre>
          <p>the execution time would be of 6 seconds and the output:</p>
          <pre>Task of 4 seconds ended.
Task of 2 seconds ended.</pre>

          <h2>The effects system</h2>
          <p>What is the definition of a computation with IO and how does this work?</p>

          <h3>Effect</h3>
          <p>An effect describes a set of IO or impure operations. An effect is declared by an element of type <code>Effect.t</code>:</p>
          <pre>Module Effect.
  Record t := New {
    command : Type;
    answer : command -> Type }.
End Effect.</pre>
          <p>This record contains a type of <code>command</code>, a set of operations to communicate with the outer world, and a dependent type of <code>answer</code>, the type of answers given by the system to a command.</p>
          <p>For example, for an effect with <code>print</code> and <code>read_line</code> operations to communicate with the command-line, the declaration could be:</p>
          <pre>Inductive command : Type :=
| Print (message : LString.t)
| ReadLine.

Definition answer (c : command) : Type :=
  match c with
  | Print _ => unit
  | ReadLine => LString.t
  end.

Definition effect : Effect.t :=
  Effect.New command answer.</pre>
          <p>A command is a <code>Print message</code> or a <code>ReadLine</code>. The answer for a <code>Print</code> is of type <code>unit</code>, the answer for a <code>ReadLine</code> is of type <code>LString.t</code>. Notice that we only declare the effect, the definition of how to actually execute it is given latter during compilation. Most effects are declared this way, with a sum type for the command type. A composition of two effects is made up by combining their command sum types.</p>

          <h3>Computation</h3>
          <p>The computations are used to write programs with IO by assembling pure Coq expressions with external calls to the system. A computation returning a value of type <code>A</code> with the effect <code>E</code> lives in the inductive type <code>C.t E A</code>:</p>
          <pre>Module C.
  Inductive t (E : Effect.t) : Type -> Type :=
  | Ret : forall (A : Type) (x : A), t E A
  | Call : forall (command : Effect.command E), t E (Effect.answer E command)
  | Let : forall (A B : Type), t E A -> (A -> t E B) -> t E B
  | Choose : forall (A : Type), t E A -> t E A -> t E A
  | Join : forall (A B : Type), t E A -> t E B -> t E (A * B).
End C.</pre>
          <p>A computation can be:</p>
          <ul>
            <li><code>Ret e</code>: the pure expression <code>e</code>;</li>
            <li><code>Call c</code>: the call of the command <code>c</code>, waiting for an answer of type <code>answer c</code> from the system;</li>
            <li><code>Let e1 e2</code>: the sequential composition and binding of <code>e1</code> and <code>e2</code>. The term <code>e2</code> is a function, applied to the result of the computation <code>e1</code>. We used the notation <code>let! x := e1 in e2</code> for <code>Let e1 (fun x => e2)</code>;</li>
            <li><code>Choose e1 e2</code>: either <code>e1</code> or <code>e2</code>. The way the choice is made is not specified. In practice, it can be the first computation to terminate;</li>
            <li><code>Join e1 e2</code>: the couple of computations <code>e1</code> and <code>e2</code>, concurrently executed.</li>
          </ul>
          <p>As for the definition of <code>Effect.t</code>, this definition is abstract: nothing is said about the implementation of these five primitives till compilation. The main advantage is that we do not need to introduce any axioms to reason about IO.</p>
          <p>The <a href="https://www.haskell.org/">Haskell</a> user can recognize here the definition of a monad, with the <em>return</em> being the <code>Ret</code> and the <em>bind</em> being the <code>Let</code>:</p>
          <pre>Ret : A -> C.t E A
Let : C.t E A -> (A -> C.t E B) -> C.t E B</pre>
          <p>As you can see, it is possible to lift a pure expression of type <code>A</code> to a computation of type <code>C.t E A</code> with the <code>Ret</code> constructor, but it is impossible to do the reverse. The only way to access the result of a computation is by providing a function returning another computation, using the constructor <code>Let</code>. This corresponds to the intuition that a program containing a program with IO is also a program with IO, so the property of being with IO is hereditary.</p>

          <h3>Compilation</h3>
          <p>In order to be executed, the computations are compiled into OCaml programs with IO. This compilation is done by customizing the <a href="https://coq.inria.fr/refman/Reference-Manual025.html">extraction mechanism</a> used to compile pure Coq expressions to pure OCaml programs. The effects and computation primitives are extracted to explicit <a href="http://ocsigen.org/lwt/">Lwt</a> constructs. Lwt is a popular library for asynchronous IO in OCaml. This compilation phase is not formally verified.</p>

          <h2>Verification by use cases</h2>
          <p>A popular technique to specify interactive programs with a lot of IO is do define <a href="https://en.wikipedia.org/wiki/Use_case">use cases</a>. A use case is basically a scenario of execution of the program, defined as a list of interaction steps between the program and the external world.</p>

          <h3>Use case</h3>
          <p>Let us take the previous example of <code>your_name</code>:</p>
          <pre>(** Ask for the user name and answer hello. *)
Definition your_name (argv : list LString.t) : C.t System.effect unit :=
  do! System.log (LString.s "What is your name?") in
  let! name := System.read_line in
  match name with
  | None => ret tt
  | Some name => System.log (LString.s "Hello " ++ name ++ LString.s "!")
  end.</pre>
          <p>A use case for a valid execution is:</p>
          <ul>
            <li>the program displays "What is your name?" on the terminal;</li>
            <li>the program asks to read a new line;</li>
            <li>the user answers by the string <em>name</em>;</li>
            <li>the program displays a message containing the string <em>name</em>.</li>
          </ul>
          <p>This use case is parametrized by a string <em>name</em>. We could write a test program interacting with <code>your_name</code>, answering the <em>name</em> string to the <code>read_line</code> request and checking that the program outputs are as expected. The limitation of this method is that we can only test a finite number of <em>name</em> values, instead of all the possible strings.</p>

          <h3>Run</h3>
          <p>To cover all the use case instances, Coq.io introduces the notion of <em>run</em>. A run describes one execution of a computation, by programming the behavior of the computation's environment in a particular execution. Said otherwise, a run contains two programs: the computation itself and its environment, with typing rules ensuring that the environment answers to each request of the computation.</p>
          <p>A run is of type <code>Run.t e v</code>, where <code>e</code> is a computation and <code>v</code> is the expected result of the computation. We formally define this type by:</p>
          <pre>Module Run.
  Inductive t : forall {E : Effect.t} {A : Type}, C.t E A -> A -> Type :=
  | Ret : forall {E A} (x : A), t (C.Ret (E := E) A x) x
  | Call : forall E (c : Effect.command E) (answer : Effect.answer E c),
    t (C.Call (E := E) c) answer
  | Let : forall {E A B} {c_x : C.t E A} {x : A} {c_f : A -> C.t E B} {y : B},
    t c_x x -> t (c_f x) y -> t (C.Let A B c_x c_f) y
  | ChooseLeft : forall {E A} {c_x1 c_x2 : C.t E A} {x1 : A},
    t c_x1 x1 -> t (C.Choose A c_x1 c_x2) x1
  | ChooseRight : forall {E A} {c_x1 c_x2 : C.t E A} {x2 : A},
    t c_x2 x2 -> t (C.Choose A c_x1 c_x2) x2
  | Join : forall {E A B} {c_x : C.t E A} {x : A} {c_y : C.t E B} {y : B},
    t c_x x -> t c_y y -> t (C.Join A B c_x c_y) (x, y).
End Run.</pre>
          <p>Seemingly complex, this definition follows the one of the computations adding the definition of an environment. You do not need to read this definition carefully, just to get the intuition that:</p>
          <ul>
            <li>the run of <code>C.Ret e</code> is just the computation with an empty environment;</li>
            <li>the run of <code>C.Call c</code> is this call together with an environment given by an answer to this call;</li>
            <li>the run of <code>C.Let e1 e2</code> is a sequence of a run of <code>e1</code> and a run of <code>e2</code>;</li>
            <li>the run of <code>C.Choose e1 e2</code> is either a run of <code>e1</code> or a run of <code>e2</code>;</li>
            <li>the run of <code>C.Join e1 e2</code> is the run of <code>e1</code> and a run of <code>e2</code>. Even if these two runs may actually interact, we are only interested in their projections on <code>e1</code> and <code>e2</code>.</li>
          </ul>
        </div>
      </div>
<%= footer %>
